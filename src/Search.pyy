from AdaSearch2D import Adasearch2D
from AdaSearch2_5D import Adasearch2_5D
from GridMap2D import GridMap2D
from GridMap2_5D import GridMap2_5D
from Drone import Drone
from Flight import Flight
import sys
import math
import argparse
sys.path.insert(1, './Utils/')
from DroneStatus import DroneStatus
from DroneType import DroneType
from Position import Position
from Velocity import Velocity
import numpy as np

class Search:
	def __init__(self, gridx, gridy, gridz, resx, resy, resz, sources, back_min, back_max, rad_min, rad_max, dimensions, verbose, emissions=None): 
		self.tau = 1
		self.background_min = back_min
		self.background_max = back_max
		self.rad_min = rad_min
		self.rad_max = rad_max
		self.verbose = verbose 
		self.solved = False
		if dimensions == 2:
			self.grid_map = GridMap2D(gridx, gridy, resx, resy, rad_max, sources)
			self.search = Adasearch2D(0, sources, back_min, back_max, rad_min, rad_max, gridx, gridy, resx, resy, self.grid_map)
		elif dimensions == 3:
			self.grid_map = GridMap2_5D(sources, "test_env.txt")
			self.search = Adasearch2_5D(0, sources, back_min, back_max, rad_min, rad_max, self.grid_map)
		else:
			raise Exception("Invalid number of dimensions. Should be 2 or 3.")
		self.drone = Drone(DroneType.Matrice100, Position(), Velocity())
		true_emissions_grid = emissions
		if true_emissions_grid == None:
			true_emissions_grid = self.grid_map.generate_emissions_grid(self.background_min, self.background_max, self.rad_min, self.rad_max)
		else:
			self.grid_map.set_emissions_grid(true_emissions_grid)
		self.raster_path = self.grid_map.get_raster_path()

	def run_iteration(self, iteration):
#		print("Running iteration"+ str(iteration))
		if self.grid_map.solved():
			emitters = []
			for emitter in self.grid_map.get_emitters():
				emitters.append(emitter.get_pos())
				if self.verbose:
					print(emitter.get_pos())
			self.solved = True
			return emitters
		else:
			sensing_config = self.grid_map.get_sensing_config(self.raster_path, self.tau, iteration)
			#Simulate flying a round of data collection
			self.fly_round(sensing_config, self.search.new_measurement)
			if self.verbose:
				print("Iteration complete")

	"""
	Runs the main algorithm
	"""
	def start(self, emissions=None):
		#Get the "true" emissions grid and raster_path
		true_emissions_grid = emissions
		if true_emissions_grid == None:
			true_emissions_grid = self.grid_map.generate_emissions_grid(self.background_min, self.background_max, self.rad_min, self.rad_max)
		else:
			self.grid_map.set_emissions_grid(true_emissions_grid)
		self.raster_path = self.grid_map.get_raster_path()

		'''
		containers = self.grid_map.containers
		observation_points = []
		for container in container:
			for cell in container.cells:
				obs = cell.get_observation_point()
				observation_points.append(obs)
		raster_path = TSP.getPath(self.grid_map, observation_points)
		'''

		iteration = 0
		if self.verbose:
			print(true_emissions_grid)
		#Runs until we have found the number of emitters we are looking for
		while not self.grid_map.solved():
			#Get the new sensing_config for the current iteration
			sensing_config = self.grid_map.get_sensing_config(raster_path, self.tau, iteration)
			print(sensing_config)
			#Simulate flying a round of data collection
			self.fly_round(sensing_config, self.search.new_measurement)
			iteration+=1
			if self.verbose:
				print("Iteration complete")
		emitters = []
		for emitter in self.grid_map.get_emitters():
			emitters.append(emitter.get_pos())
			if self.verbose:
				print(emitter.get_pos())
		return emitters


	"""
	Simulates flying a round of data collection

	inputs:
	path -- path of points to fly
	new_measurement -- callback function from the search algorithm for new measurements
	"""
	def fly_round(self, path, new_measurement):
		flight = Flight(path, self.drone, self.grid_map, new_measurement)
		flight.start()

parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", help="Verbose", default=False, type=bool)

args = parser.parse_args()

if __name__ == '__main__':
	s = Search(6, 6, 4, 4, 4, 4, 1, 0, 400, 800, 1000, 3, args.verbose)
	iteration = 0
	while not s.solved:
		emitters = s.run_iteration(iteration)
		iteration+=1
	print(emitters)

